<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Image with Pinch-to-Zoom and Pan (No VR Button)</title> <!-- Titre mis à jour -->

    <!-- A-Frame Library -->
    <script src=https://aframe.io/releases/1.2.0/aframe.min.js></script>

    <!-- AR.js Library for Web AR -->
    <script src=https://cdn.rawgit.com/jeromeetienne/AR.js/1.7.5/aframe/build/aframe-ar.min.js></script>

    <!-- Hammer.js Library for Gesture Recognition -->
    <script src=https://hammerjs.github.io/dist/hammer.min.js></script>
</head>

<body style="margin: 0; overflow: hidden;">

    <!-- AR Scene - SEULE MODIFICATION ICI -->
    <a-scene embedded arjs vr-mode-ui="enabled: false">
        <!-- 2D Image to Display in AR -->
        <a-image id="resizableImage" src="output_visualization.svg" position="0 1.5 -3" width="4" height="3"></a-image>
    </a-scene>

    <!-- File Input for User to Upload an Image -->
    <div style="position: fixed; top: 10px; left: 10px;">
        <input type="file" id="imageUpload" accept="image/*" />
    </div>

    <!-- Script for Handling Gestures and Image Upload -->
    <script>
        // Get the image element in the AR scene
        var image = document.getElementById('resizableImage');

        // --- Variables for tracking state ---
        var currentScale = { x: 1, y: 1, z: 1 }; // Store current scale factors
        var initialPosition = { x: 0, y: 0, z: 0 }; // To store position at the start of a pan
        var panSensitivity = 0.001; // Adjust this for drag speed (pixels to world units) - Remis une valeur par défaut
        var isPanning = false; // Flag pour savoir si un pan est en cours
        var baseScaleOnPinchStart = 1; // Pour stocker l'échelle au début du pinch

        // Initialize Hammer.js on the entire document body
        var mc = new Hammer(document.body);

        // --- Configure Gestures ---
        mc.get('pinch').set({ enable: true });
        mc.get('pan').set({ enable: true }); // Pan dans toutes les directions

        // Allow pinch and pan recognizers to work together
        mc.get('pinch').recognizeWith(mc.get('pan'));

        // --- Event Listeners ---

        // Pinch event listener to scale the image
        mc.on('pinchstart', function(ev) {
             // Si on pince, on ne déplace pas en même temps
             isPanning = false;
             // Stocker l'échelle actuelle au début du pincement
             baseScaleOnPinchStart = currentScale.x;
        });
        mc.on('pinch', function (ev) {
            // Appliquer l'échelle relative de Hammer à l'échelle de base
            let scaleValue = baseScaleOnPinchStart * ev.scale;

            image.setAttribute('scale', `${scaleValue} ${scaleValue} 1`);
        });
        mc.on('pinchend pinchcancel', function(ev) {
            // Met à jour l'échelle de base lorsque le pincement se termine
             currentScale = image.getAttribute('scale');
        });


        // Pan start listener - records the starting X and Y position
        mc.on('panstart', function(ev) {
            // Ne commence le pan que si ce n'est pas un pinch (un seul doigt)
            if (ev.pointers.length === 1 && !mc.get('pinch').isRecognizing) { // Vérifie aussi que pinch n'est pas actif
                 isPanning = true;
                 initialPosition = image.getAttribute('position');
            } else {
                 isPanning = false;
            }
        });

        // Pan move listener - handles the horizontal and vertical dragging
        mc.on('panmove', function (ev) {
             if (!isPanning) return; // Ne déplace pas si on est en train de pincer ou si pan non démarré correctement

            // Calculate the new X and Y positions based on initial position and drag amount
            let newX = initialPosition.x + (ev.deltaX * panSensitivity*-1);
            // Inverser Y car l'axe Y de l'écran est souvent inversé par rapport à A-Frame
            let newY = initialPosition.y + (ev.deltaY * panSensitivity);

            // Apply the new position (changing X and Y, keeping Z)
            image.setAttribute('position', {
                x: newX,
                y: newY,
                z: initialPosition.z // Keep the original Z depth
            });
        });

        mc.on('panend pancancel', function(ev) {
            // Met à jour la position initiale pour le prochain pan si on a effectivement panné
            if(isPanning) {
                initialPosition = image.getAttribute('position');
            }
            isPanning = false;
        });

        // Image upload functionality
        document.getElementById('imageUpload').addEventListener('change', function (event) {
            var file = event.target.files[0]; // Get the selected file
            if (file) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    // Set the image source to the uploaded image
                    image.setAttribute('src', e.target.result);
                    // Reset scale and position when a new image is loaded
                    currentScale = { x: 1, y: 1, z: 1 };
                    baseScaleOnPinchStart = 1; // Réinitialise aussi l'échelle de base
                    image.setAttribute('scale', '1 1 1');
                    // Remet à la position initiale définie dans le HTML
                    image.setAttribute('position', '0 1.5 -3');
                    initialPosition = image.getAttribute('position'); // Met à jour la variable JS aussi
                };
                reader.readAsDataURL(file); // Read the file as a Data URL
            }
        });
    </script>
</body>
</html>
