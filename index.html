<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Image with Stepped Pan & Pinch Zoom</title> <!-- Titre mis à jour -->

    <!-- A-Frame Library -->
    <script src=https://aframe.io/releases/1.2.0/aframe.min.js></script>

    <!-- AR.js Library for Web AR -->
    <script src=https://cdn.rawgit.com/jeromeetienne/AR.js/1.7.5/aframe/build/aframe-ar.min.js></script>

    <!-- Hammer.js Library for Gesture Recognition -->
    <script src=https://hammerjs.github.io/dist/hammer.min.js></script>
</head>

<body style="margin: 0; overflow: hidden;">

    <!-- AR Scene -->
    <a-scene embedded arjs vr-mode-ui="enabled: false">
        <a-image id="resizableImage" src="output_visualization.svg" position="0 1.5 -3" width="4" height="3"></a-image>
    </a-scene>

    <!-- File Input -->
    <div style="position: fixed; top: 10px; left: 10px;">
        <input type="file" id="imageUpload" accept="image/*" />
    </div>

    <!-- Script -->
    <script>
        var image = document.getElementById('resizableImage');

        // --- Variables for tracking state ---
        var currentScale = { x: 1, y: 1, z: 1 };
        var initialPosition = { x: 0, y: 0, z: 0 }; // Position au début du pan
        var currentPosition = { x: 0, y: 0, z: 0 }; // Position actuelle calculée par pas
        var isPanning = false;
        var baseScaleOnPinchStart = 1;

        // --- NOUVEAUX PARAMÈTRES POUR LE DÉPLACEMENT PAR PAS ---
        // Taille d'un pas (en unités A-Frame)
        var stepSizeX = 0.2; // Déplacement horizontal par pas
        var stepSizeY = 0.2; // Déplacement vertical par pas

        // Seuil en pixels pour déclencher un pas
        var pixelThresholdX = 40; // Nb pixels horizontal à parcourir pour un pas
        var pixelThresholdY = 40; // Nb pixels vertical à parcourir pour un pas

        // Pour suivre le nombre de pas déjà effectués dans ce geste
        var stepsTakenX = 0;
        var stepsTakenY = 0;
        // ---------------------------------------------------------


        // Initialize Hammer.js
        var mc = new Hammer(document.body);

        // --- Configure Gestures ---
        mc.get('pinch').set({ enable: true });
        mc.get('pan').set({ enable: true }); // Pan toutes directions
        mc.get('pinch').recognizeWith(mc.get('pan'));

        // --- Event Listeners ---

        // == Pinch (Zoom) - Pas de changement majeur ==
        mc.on('pinchstart', function(ev) {
             isPanning = false; // Arrêter le pan si on pince
             baseScaleOnPinchStart = currentScale.x;
        });
        mc.on('pinch', function (ev) {
            let scaleValue = baseScaleOnPinchStart * ev.scale;
            image.setAttribute('scale', `${scaleValue} ${scaleValue} 1`);
        });
        mc.on('pinchend pinchcancel', function(ev) {
             currentScale = image.getAttribute('scale');
        });


        // == Pan (Déplacement) - LOGIQUE MODIFIÉE ==
        mc.on('panstart', function(ev) {
            // Commence le pan uniquement si 1 doigt et pas en train de pincer
            if (ev.pointers.length === 1 && !mc.get('pinch').isRecognizing) {
                 isPanning = true;
                 // Enregistre la position au TOUT début du geste
                 initialPosition = image.getAttribute('position');
                 // Initialise la position courante (qui sera modifiée par pas)
                 currentPosition = { ...initialPosition }; // Copie de l'objet
                 // Réinitialise les compteurs de pas pour ce nouveau geste
                 stepsTakenX = 0;
                 stepsTakenY = 0;
            } else {
                 isPanning = false;
            }
        });

        mc.on('panmove', function (ev) {
             if (!isPanning) return; // Ne rien faire si on n'est pas en mode pan

             // ev.deltaX / ev.deltaY = Déplacement TOTAL en pixels depuis panstart

             // Calculer combien de pas CORRESPONDENT au déplacement total en pixels
             let targetStepsX = Math.floor(ev.deltaX / pixelThresholdX);
             // Pas besoin d'inverser ici, on regarde juste la magnitude du déplacement en pixels
             let targetStepsY = Math.floor(ev.deltaY / pixelThresholdY);

             // Vérifier si le nombre de pas cible a changé depuis la dernière fois
             let needsUpdate = false;
             if (targetStepsX !== stepsTakenX) {
                 currentPosition.x = initialPosition.x + (targetStepsX * stepSizeX);
                 stepsTakenX = targetStepsX;
                 needsUpdate = true;
             }
             if (targetStepsY !== stepsTakenY) {
                 // Appliquer l'inversion Y ici si nécessaire lors du calcul de la position finale
                 // Si le déplacement était correct SANS * -1 avant, ne PAS l'ajouter ici.
                 // Si le déplacement était correct AVEC * -1 avant, AJOUTER * -1 ici.
                 currentPosition.y = initialPosition.y + (targetStepsY * stepSizeY * -1); // <-- AJUSTER SI BESOIN (enlever ou garder * -1)
                 stepsTakenY = targetStepsY;
                 needsUpdate = true;
             }

             // Mettre à jour la position de l'image A-Frame SEULEMENT si un pas a été franchi
             if (needsUpdate) {
                 image.setAttribute('position', {
                     x: currentPosition.x,
                     y: currentPosition.y,
                     z: initialPosition.z // Garde la profondeur Z initiale
                 });
             }
        });

        mc.on('panend pancancel', function(ev) {
            // Pas forcément besoin de faire qqchose ici, mais on reset le flag
            isPanning = false;
            // On pourrait enregistrer la position finale comme nouvelle 'initialPosition'
            // si on voulait que le prochain pan parte de là, mais la logique actuelle
            // repart toujours de la position au début du geste 'panstart'.
            // initialPosition = image.getAttribute('position'); // Optionnel
        });

        // == Image Upload - Pas de changement ==
        document.getElementById('imageUpload').addEventListener('change', function (event) {
            var file = event.event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    image.setAttribute('src', e.target.result);
                    currentScale = { x: 1, y: 1, z: 1 };
                    baseScaleOnPinchStart = 1;
                    image.setAttribute('scale', '1 1 1');
                    let resetPos = {x: 0, y: 1.5, z: -3}; // Position initiale
                    image.setAttribute('position', resetPos);
                    initialPosition = { ...resetPos }; // Mettre à jour la var JS
                    currentPosition = { ...resetPos };
                };
                reader.readAsDataURL(file);
            }
        });
    </script>
</body>
</html>
