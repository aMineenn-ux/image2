<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Image with Pinch-to-Zoom and Pan</title>

    <!-- A-Frame Library -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <!-- AR.js Library for Web AR -->
    <script src="https://cdn.rawgit.com/jeromeetienne/AR.js/1.7.5/aframe/build/aframe-ar.min.js"></script>
    <!-- Hammer.js Library for Gesture Recognition -->
    <script src="https://hammerjs.github.io/dist/hammer.min.js"></script>
</head>

<body style="margin: 0; overflow: hidden;">

    <!-- AR Scene -->
    <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;'> <!-- Ajout options AR.js, debugUI peut être utile -->
        <!-- Marqueur par défaut (Hiro) -->
        <a-marker preset="hiro">
            <!-- Image à l'intérieur du marqueur pour qu'elle bouge avec -->
            <a-image id="resizableImage" src="output_visualization.svg" position="0 0 0" rotation="-90 0 0" width="1" height="0.75" scale="1 1 1"></a-image>
            <!-- Note: J'ai mis l'image DANS le marqueur et ajusté position/rotation/taille -->
            <!-- La rotation -90 0 0 est souvent nécessaire pour que l'image soit à plat sur le marqueur -->
            <!-- La position 0 0 0 la centre sur le marqueur -->
            <!-- La taille (width/height) est relative au marqueur (qui a une taille de 1x1 par défaut) -->
        </a-marker>
         <!-- Caméra fixe -->
        <a-entity camera></a-entity>
    </a-scene>

    <!-- File Input for User to Upload an Image -->
    <div style="position: fixed; top: 10px; left: 10px; z-index: 1;">
        <input type="file" id="imageUpload" accept="image/*" />
    </div>

    <!-- Script for Handling Gestures and Image Upload -->
    <script>
        // Attendre que A-Frame soit chargé (bonne pratique)
        document.addEventListener('DOMContentLoaded', (event) => {
            var image = document.getElementById('resizableImage');
            if (!image) {
                console.error("L'élément image 'resizableImage' n'a pas été trouvé !");
                return;
            }

            var currentScale = 1; // Track current scale factor for pinch
            var isPanning = false;
            var startPosition = null; // Initialisé à null
            var startScale = null;    // Pour mieux gérer le pinch

            const panSensitivity = 0.003; // Sensibilité ajustée (à tester)
            const sceneEl = document.querySelector('a-scene');

            // Initialize Hammer.js sur le corps (ou la scène A-Frame si préféré)
            var mc = new Hammer(document.body); // Ou new Hammer(sceneEl)

            // --- Enable Gestures ---
            mc.get('pinch').set({ enable: true });
            mc.get('pan').set({ direction: Hammer.DIRECTION_ALL, enable: true });

            // --- Pinch Event Listeners (Zoom) ---
             mc.on('pinchstart', function(ev) {
                if (image) {
                    startScale = image.getAttribute('scale');
                }
             });

            mc.on('pinch', function (ev) {
                if (isPanning || !startScale || !image) return;

                // Appliquer l'échelle par rapport à l'échelle de départ du pinch
                let newScaleFactor = ev.scale; // L'échelle fournie par Hammer est relative au début du geste
                image.setAttribute('scale', {
                    x: startScale.x * newScaleFactor,
                    y: startScale.y * newScaleFactor,
                    z: startScale.z // Garder Z à 1 ou startScale.z
                });
            });

             mc.on('pinchend', function(ev) {
                 startScale = null; // Réinitialiser pour le prochain pinch
             });


            // --- Pan Event Listeners (Move) ---
            mc.on('panstart', function(ev) {
                if (image) {
                    isPanning = true;
                    startPosition = image.getAttribute('position');
                     console.log("Pan Start - Start Position:", startPosition);
                } else {
                     console.error("Pan Start: Image non trouvée");
                }
            });

            mc.on('panmove', function (ev) {
                if (!isPanning || !startPosition || !image) {
                    //console.log("Pan Move Ignored: ", {isPanning, startPosition: !!startPosition, image: !!image});
                    return;
                }

                // Calculer le nouveau déplacement X et Y dans le plan du marqueur
                // Note: l'axe Y de l'écran est inversé par rapport à l'axe Y d'A-Frame
                // Mais comme l'image est tournée de -90 degrés sur X,
                // le deltaX de l'écran correspond au X de l'image,
                // et le deltaY de l'écran correspond au Z de l'image (pas au Y).
                // Ajustons cela !
                let newX = startPosition.x + ev.deltaX * panSensitivity;
                let newY = startPosition.y; // On ne bouge pas sur l'axe Y (hauteur par rapport au marqueur)
                let newZ = startPosition.z - ev.deltaY * panSensitivity; // Le Y de l'écran déplace sur Z

                 //console.log("Pan Move - Delta:", ev.deltaX, ev.deltaY, "New Pos:", newX, newY, newZ);

                // Apply the new position to the image element
                image.setAttribute('position', { x: newX, y: newY, z: newZ });
            });

            mc.on('panend', function(ev) {
                console.log("Pan End");
                isPanning = false;
                startPosition = null; // Clear start position
            });


            // --- Image Upload Functionality ---
            var imageUpload = document.getElementById('imageUpload');
            if(imageUpload) {
                imageUpload.addEventListener('change', function (event) {
                    var file = event.target.files[0];
                    if (file && image) {
                        var reader = new FileReader();
                        reader.onload = function (e) {
                            image.setAttribute('src', e.target.result);
                            // Réinitialiser l'échelle et la position lors du chargement d'une nouvelle image
                            image.setAttribute('scale', '1 1 1');
                            image.setAttribute('position', '0 0 0'); // Réinitialiser à la position centrale sur le marqueur
                            currentScale = 1;
                            startScale = {x:1, y:1, z:1}; // Mettre à jour startScale aussi
                            console.log("Image chargée et réinitialisée");
                        };
                        reader.readAsDataURL(file);
                    }
                });
            } else {
                 console.error("L'élément input 'imageUpload' n'a pas été trouvé !");
            }

            // --- Prevent Default Touch Actions ---
            document.body.addEventListener('touchstart', function(e) {
                if (e.target.tagName !== 'INPUT') {
                    e.preventDefault();
                }
            }, { passive: false });
            document.body.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, { passive: false });

            console.log("Script initialisé, écouteurs d'événements ajoutés.");
        }); // Fin de DOMContentLoaded

    </script>
</body>
</html>
